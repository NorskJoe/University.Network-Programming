package assignment_new;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;


/**
 * Server class runs game loop.  Will always run until user aborts the program.
 * 
 * Holds all the connection and game variables that will be used.
 * 
 * @author Joseph Johnson
 *
 */
public class Server 
{
	// Loggers used to log all information to relevant log files.  One for communication, one for game information
	final Logger commLogger = Logger.getLogger(Server.class.getName() + "communication");
	final Logger gameLogger = Logger.getLogger(Server.class.getName() + "game");
	
	// Connection variables
	final int PORT_NUMBER = 12413;
	private ServerSocket serverSocket;
	BufferedReader in;
	PrintWriter out;
	DatagramSocket datagram;
	InetAddress group;
	
	// Game variables
	int attemptedConnection = 0; // Goes to a maximum of 5 before a game is started.
	int actualConnection = 0; // The number of players who actually joined the game
	int currentRoundPlayerCount; // The number of players in a current round (max is 3)
	int randomInt; // Random int used in the game logic
	int closestGuess = Integer.MAX_VALUE; // variable used to find the winner
	boolean allPlayersGuessed = false; // boolean flag indicating if all players have guessed in this round
	boolean gameIsPlaying = true; // boolean flag indicating a game is in progress
	ArrayList<String> winners; // A string of winners names, used to multicast
	ArrayList<Integer> generatedInts; // A list of the numbers generated by players
	HashMap<String, Integer> playerGuesses; // A map linking players to their guesses
	HashMap<Integer, Thread> clients; // A map of the players and their id

	public static void main(String[] args) 
	{
		new Server();
	}
	
	public Server()
	{
		// Setup loggers
		try {
			setupLoggers();
			
		} catch (IOException e) {
			e.printStackTrace();
		}

		// Set up datagram so that we can multicast
		try {
			datagram = new DatagramSocket();
			group = InetAddress.getByName("224.0.0.3");
			
		} catch (SocketException e) {
			e.printStackTrace();
		} catch (UnknownHostException e) {
			e.printStackTrace();
		}
		
		// Generate random number for server
		randomInt = generateNumber();
		gameLogger.info("Server generated the random number: " + randomInt);
		
		// Start server socket 
		try {
			startServer();
			
		} catch (IOException e) {
			System.out.println("The server is already running!");
		}
		
		
		// Start playing the game/listening for players
		commLogger.info("The server is now listening for connections.");
		startGame();
		
	}

	
	/**
	 * Generates the number used in deciding the winner
	 * 
	 * @return (int) a random number between 0 and 2
	 */
	private static int generateNumber() 
	{
		Random generator = new Random();
		int temp = generator.nextInt(3);
		return temp;
	}

	
	/**
	 * The main logic of the game is here.
	 * 
	 * Each game has a maximum of 5 players.  The client will wait 15 seconds for each
	 * player to connect.  Once it has some players, it will decide wether to play 2 rounds
	 * (e.g. first round of 3 players, then second round with 2 players).
	 * It will then reset all the game variables for the next game.
	 * 
	 */
	private void startGame() 
	{
		generatedInts = new ArrayList<Integer>();
		winners = new ArrayList<String>();
		playerGuesses = new HashMap<String, Integer>();
		clients = new HashMap<Integer, Thread>();
		
		// Loop that accepts players, this loop will not end unless server is force quit
		while(true)
		{
			// Ready to start a game
			if(attemptedConnection >= 5)
			{
				gameLogger.info("The game has enough players.  Starting a game.");
				// Maximuim of 5 connections at a time, as per specs
				int numberOfPlayers = clients.size();
				// Only 3 players can play at once, so seperate game into two rounds
				if(numberOfPlayers >= 3)
				{
					playTwoRounds(numberOfPlayers);
					
				}
				else // Less than 3 players joined the game, all can play in one round
				{
					playOneRound();
					
				}
				// Reset all the variables for the next game
				resetGameVariables();
				gameLogger.info("This game is finished, waiting for more players.");

			}
			
			
			try {
				// Accept connection and add them to the client/player list
				Socket client = serverSocket.accept();
				Thread thread = new Thread (new ServerConnection(actualConnection, client, randomInt, this));
				clients.put(actualConnection, thread); // Add each player to the player map
				commLogger.info("A player connected to the game");
				attemptedConnection++;
				actualConnection++;
				
			} catch (SocketTimeoutException e) {
				System.out.println("The client took too long to respond, they will not play this round");
				attemptedConnection++;
				continue;
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		
	}

	/**
	 * Executes all the players in the map in one round.  
	 * Waits for all players to be finished before continuing.
	 * 
	 */
	private void playOneRound() 
	{
		currentRoundPlayerCount = clients.size();
		// Run all the threads
		for(Thread clients : clients.values())
		{
			clients.start();
		}
		
		//  Wait for game to finish
		while(gameIsPlaying)
		{
			System.out.print("");
			if(clients.size() == 0)
			{
				break;
			}
		}
		
	}
	
	/**
	 * Executes the players in the map in two rounds, first round will
	 * have 3 players, second round will have the remaining.
	 * 
	 * @param numberOfPlayers
	 */
	private void playTwoRounds(int numberOfPlayers) {
		currentRoundPlayerCount = 3;
		// execute the first three only
		for(int i = 0; i < 3; i++)
		{
			clients.get(i).start();
		}
		
		// Wait for all thread in this round to finish
		while(gameIsPlaying) 
		{
			System.out.print("");
			if(clients.size() == (numberOfPlayers - 3))
			{				
				break;
			}
		}
		currentRoundPlayerCount = clients.size();
		resetRoundVariables();
		// execute the remaining threads
		for(Thread client : clients.values())
		{
			client.start();
		}
		
		// Wait for round to finish
		while(gameIsPlaying)
		{
			System.out.print("");
			if(clients.size() == 0)
			{
				break;
			}
		}
		
	}

	/**
	 * Resets all the relevant variables between 2 rounds
	 * 
	 */
	private void resetRoundVariables() 
	{
		generatedInts = new ArrayList<Integer>();
		winners = new ArrayList<String>();
		playerGuesses = new HashMap<String, Integer>();
		closestGuess = Integer.MAX_VALUE;
		
	}

	/**
	 * Resets all variables for a new game where new players will join.
	 * 
	 */
	private void resetGameVariables() 
	{
		resetRoundVariables();
		clients = new HashMap<Integer, Thread>();
		attemptedConnection = 0;
		actualConnection = 0;
		
	}

	/**
	 * Opens the server socket
	 * 
	 * @throws IOException
	 */
	private void startServer() throws IOException 
	{
		serverSocket = new ServerSocket(PORT_NUMBER);
		serverSocket.setSoTimeout(15*1000);
		commLogger.info("ServerSocket started");
	}

	/**
	 * Sets up loggers used to log all communication.
	 * 
	 * One logger used for game information.
	 * One logger used for connection information.
	 * 
	 * @throws IOException
	 */
	private void setupLoggers() throws IOException 
	{
		FileHandler comFile = new FileHandler("communication.log");
		FileHandler gameFile = new FileHandler("game.log");
		comFile.setFormatter(new SimpleFormatter());
		gameFile.setFormatter(new SimpleFormatter());
		commLogger.addHandler(comFile);
		gameLogger.addHandler(gameFile);
		commLogger.setUseParentHandlers(false);
		gameLogger.setUseParentHandlers(false);
		
	}



}
